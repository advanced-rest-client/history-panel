<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>history-panel test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../../app-pouchdb/pouchdb.html">
  <link rel="import" href="../../arc-models/request-model.html">
  <link rel="import" href="../../arc-models/project-model.html">
  <link rel="import" href="../../arc-models/url-indexer.html">
  <link rel="import" href="../../arc-data-generator/arc-data-generator.html">
  <link rel="import" href="../history-panel.html">
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <history-panel no-auto no-auto-projects></history-panel>
    </template>
  </test-fixture>

  <test-fixture id="NoAuto">
    <template>
      <project-model></project-model>
      <request-model></request-model>
      <url-indexer></url-indexer>
      <history-panel no-auto></history-panel>
    </template>
  </test-fixture>

  <test-fixture id="Models">
    <template>
      <request-model></request-model>
      <project-model></project-model>
      <url-indexer></url-indexer>
      <history-panel></history-panel>
    </template>
  </test-fixture>

  <script>
  /* global DataGenerator, chance */
  function doneAfterQuery(element, done) {
    element.addEventListener('querying-changed', function f(e) {
      if (e.detail.value) {
        return;
      }
      element.removeEventListener('querying-changed', f);
      flush(() => done());
    });
  }

  suite('notifyResize()', () => {
    test('Do nothing when DOM is not initialized', () => {
      const element = fixture('Basic');
      element.notifyResize();
    });

    test('Calls list\'s notifyResize', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const list = element.shadowRoot.querySelector('history-panel-list');
        let called = false;
        list.notifyResize = () => called = true;
        element.notifyResize();
        assert.isTrue(called);
        done();
      });
    });
  });

  suite('_computeListHidden()', () => {
    let element;
    suiteSetup(() => {
      element = fixture('Basic');
    });

    test('Returns false when isSearch is true', () => {
      let result = element._computeListHidden(true, true);
      assert.isFalse(result);
      result = element._computeListHidden(false, true);
      assert.isFalse(result);
    });

    test('Returns false when hasRequests is true', () => {
      let result = element._computeListHidden(true);
      assert.isFalse(result);
    });

    test('Returns true when hasRequests is false', () => {
      let result = element._computeListHidden(false);
      assert.isTrue(result);
    });
  });

  suite('_navigateHandler()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Sets detailsOpened to false', () => {
      element.detailsOpened = true;
      element._navigateHandler();
      assert.isFalse(element.detailsOpened);
    });
  });

  suite('_onDetails()', () => {
    let element;
    let eData;
    setup((done) => {
      element = fixture('Basic');
      eData = {
        detail: {
          request: DataGenerator.generateHistoryObject()
        }
      };
      flush(() => done());
    });

    test('Sets request on request details dialog', () => {
      element._onDetails(eData);
      assert.isTrue(eData.detail.request === element.$.requestDetails.request);
    });

    test('Opens request details dialog', () => {
      element._onDetails(eData);
      assert.isTrue(element.detailsOpened);
    });
  });

  suite('_loadRequestDetails()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        element.$.requestDetails.request = {
          _id: 'test'
        };
        done();
      });
    });

    test('Dispatches "navigate" event', () => {
      const spy = sinon.spy();
      element.addEventListener('navigate', spy);
      element._loadRequestDetails();
      assert.isTrue(spy.called);
    });

    test('The event has base', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e.detail;
      });
      element._loadRequestDetails();
      assert.equal(data.base, 'request');
    });

    test('The event has type', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e.detail;
      });
      element._loadRequestDetails();
      assert.equal(data.type, 'history');
    });

    test('The event has id', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e.detail;
      });
      element._loadRequestDetails();
      assert.equal(data.id, 'test');
    });

    test('The event bubbles', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e;
      });
      element._loadRequestDetails();
      assert.isTrue(data.bubbles);
    });

    test('The event is composed', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e;
      });
      element._loadRequestDetails();
      if (typeof data.composed !== 'undefined') {
        assert.isTrue(data.composed);
      }
    });

    test('The event is cancelable', () => {
      let data;
      element.addEventListener('navigate', function f(e) {
        element.removeEventListener('navigate', f);
        data = e;
      });
      element._loadRequestDetails();
      assert.isTrue(data.cancelable);
    });
  });

  suite('_searchHandler()', () => {
    let element;
    let arg;
    setup((done) => {
      element = fixture('Basic');
      arg = {
        target: {
          value: 'test'
        }
      };
      flush(() => done());
    });

    test('Calls query() function', () => {
      let called = false;
      element.query = () => called = true;
      element._searchHandler(arg);
      assert.isTrue(called);
    });

    test('Passes value to query function', () => {
      let value;
      element.query = (input) => value = input;
      element._searchHandler(arg);
      assert.equal(value, 'test');
    });
  });

  suite('_deleteSelected()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => done());
    });

    test('Closes the selection menu', () => {
      let called = false;
      element._closeSelectionMenu = () => called = true;
      element._deleteSelected();
      assert.isTrue(called);
    });

    test('Calls delete function', () => {
      const arr = ['a', 'b', 'c'];
      element.selectedItems = arr;
      let value;
      element._delete = (input) => value = input;
      element._deleteSelected();
      assert.deepEqual(value, arr);
    });

    test('Does nothing when no selection', () => {
      let called = false;
      element._delete = () => called = true;
      element._deleteSelected();
      assert.isFalse(called);
    });
  });

  suite('_deleteRequestDetails()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        element.$.requestDetails.request = DataGenerator.generateHistoryObject();
        done();
      });
    });

    test('Calls delete function', () => {
      let value;
      element._delete = (input) => value = input;
      element._deleteRequestDetails();
      assert.typeOf(value, 'array');
      assert.lengthOf(value, 1);
    });

    test('Sets detailsOpened to false', () => {
      element.detailsOpened = true;
      element._delete = () => {};
      element._deleteRequestDetails();
      assert.isFalse(element.detailsOpened);
    });
  });

  suite('_dispatchDelete()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = DataGenerator.generateHistoryRequestsData({
        requestsSize: 5
      });
    });

    test('Dispatches request-objects-deleted event', () => {
      const spy = sinon.spy();
      element.addEventListener('request-objects-deleted', spy);
      element._dispatchDelete(list);
      assert.isTrue(spy.called);
    });

    test('The event bubbles', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e;
      });
      element._dispatchDelete(list);
      assert.isTrue(data.bubbles);
    });

    test('The event is composed', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e;
      });
      element._dispatchDelete(list);
      if (typeof data.composed !== 'undefined') {
        assert.isTrue(data.composed);
      }
    });

    test('The event is cancelable', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e;
      });
      element._dispatchDelete(list);
      assert.isTrue(data.cancelable);
    });

    test('The event has "detail.type"', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e.detail;
      });
      element._dispatchDelete(list);
      assert.equal(data.type, 'history');
    });

    test('The event has "detail.items"', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e.detail;
      });
      element._dispatchDelete(list);
      assert.typeOf(data.items, 'array');
      assert.lengthOf(data.items, 5);
    });

    test('The "detail.items" are IDs', () => {
      let data;
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        data = e.detail;
      });
      element._dispatchDelete(list);
      assert.typeOf(data.items[0], 'string');
    });
  });

  suite('_delete()', () => {
    teardown(() => {
      return DataGenerator.destroyHistoryData();
    });

    let element;
    setup((done) => {
      DataGenerator.insertHistoryRequestData({
        requestsSize: 5
      })
      .then(() => {
        element = fixture('Models')[3];
        doneAfterQuery(element, done);
      });
    });

    test('Dispatches request-objects-deleted event', () => {
      const spy = sinon.spy();
      element.addEventListener('request-objects-deleted', spy);
      const p = element._delete(element.requests.slice(0, 2));
      assert.isTrue(spy.called);
      return p;
    });

    test('Opens model error toast if the event is not handled', function() {
      element.addEventListener('request-objects-deleted', function f(e) {
        element.removeEventListener('request-objects-deleted', f);
        e.stopImmediatePropagation();
      });
      return element._delete(element.requests.slice(0, 2))
      .catch(() => {
        const toast = element.shadowRoot.querySelector('#noModel');
        assert.isTrue(toast.opened);
      });
    });

    test('Sets _latestDeleted', () => {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        assert.typeOf(element._latestDeleted, 'array');
        assert.lengthOf(element._latestDeleted, 2);
      });
    });

    test('_latestDeleted has _id and _rev', () => {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        const item = element._latestDeleted[0];
        assert.typeOf(item._id, 'string');
        assert.typeOf(item._rev, 'string');
      });
    });

    test('Opens delete confirmation toast', () => {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        assert.isTrue(element.$.deleteToast.opened);
      });
    });

    test('Deletes single request', () => {
      return element._delete(element.requests.slice(0, 1))
      .then(() => {
        assert.equal(element.$.deleteToast.text, 'The request has been removed.');
      });
    });
  });

  suite('_dispatchUndelete()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = [];
      for (let i = 0; i < 5; i++) {
        list[i] = {
          _id: chance.guid({version: 5}),
          _rev: chance.guid({version: 5})
        };
      }
    });

    test('Dispatches request-objects-undeleted event', () => {
      const spy = sinon.spy();
      element.addEventListener('request-objects-undeleted', spy);
      element._dispatchUndelete(list);
      assert.isTrue(spy.called);
    });

    test('The event bubbles', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e;
      });
      element._dispatchUndelete(list);
      assert.isTrue(data.bubbles);
    });

    test('The event is composed', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e;
      });
      element._dispatchUndelete(list);
      if (typeof data.composed !== 'undefined') {
        assert.isTrue(data.composed);
      }
    });

    test('The event is cancelable', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e;
      });
      element._dispatchUndelete(list);
      assert.isTrue(data.cancelable);
    });

    test('The event has "detail.type"', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e.detail;
      });
      element._dispatchUndelete(list);
      assert.equal(data.type, 'history');
    });

    test('The event has "detail.items"', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e.detail;
      });
      element._dispatchUndelete(list);
      assert.typeOf(data.items, 'array');
      assert.lengthOf(data.items, 5);
    });

    test('The "detail.items" has _id and _rev', () => {
      let data;
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        data = e.detail;
      });
      element._dispatchUndelete(list);
      assert.typeOf(data.items[0]._id, 'string');
      assert.typeOf(data.items[0]._rev, 'string');
    });
  });

  suite('revertDeleted()', () => {
    teardown(() => {
      return DataGenerator.destroyHistoryData();
    });

    let element;
    setup((done) => {
      DataGenerator.insertHistoryRequestData({
        requestsSize: 5
      })
      .then(() => {
        element = fixture('Models')[3];
        doneAfterQuery(element, done);
      });
    });

    test('Do nothing when delete was not called before', function() {
      return element.revertDeleted(); // no error is thrown
    });

    test('Closes delete confirmation toast', function() {
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        const promise = element.revertDeleted();
        assert.isFalse(element.$.deleteToast.opened);
        return promise;
      });
    });

    test('Dispatches request-objects-undeleted event', function() {
      const spy = sinon.spy();
      element.addEventListener('request-objects-undeleted', spy);
      return element._delete(element.requests.slice(0, 2))
      .then(() => {
        const promise = element.revertDeleted();
        assert.isTrue(spy.calledOnce);
        return promise;
      });
    });

    test('Undeleted restores items to the list', function() {
      const deleted = [element.requests[2], element.requests[3]];
      const sizeBefore = element.requests.length;
      return element._delete(deleted)
      .then(() => {
        assert.notEqual(element.requests.length, sizeBefore);
        return element.revertDeleted();
      })
      .then(() => {
        assert.equal(element.requests.length, sizeBefore);
      });
    });

    test('Opens model error toast if the event is not handled', function() {
      element._latestDeleted = [{}];
      element.addEventListener('request-objects-undeleted', function f(e) {
        element.removeEventListener('request-objects-undeleted', f);
        e.stopImmediatePropagation();
      });
      return element.revertDeleted()
      .catch(() => {
        const toast = element.shadowRoot.querySelector('#noModel');
        assert.isTrue(toast.opened);
      });
    });

    test('Opens revert error toast if there\'s an error', function() {
      element._latestDeleted = [{}];
      element._handleError = () => {};
      return element.revertDeleted()
      .catch(() => {
        const toast = element.shadowRoot.querySelector('#revertError');
        assert.isTrue(toast.opened);
      });
    });
  });

  suite('DOM manipulation', () => {
    suite('No data', () => {
      suiteSetup(() => {
        return DataGenerator.destroyHistoryData();
      });

      let element;
      setup((done) => {
        element = fixture('Models')[3];
        doneAfterQuery(element, done);
      });

      test('hasRequests is false', () => {
        assert.isFalse(element.hasRequests);
      });

      test('empty message is rendered', () => {
        const node = element.shadowRoot.querySelector('.empty-info');
        assert.ok(node);
      });

      test('The list is hidden', () => {
        const list = element.shadowRoot.querySelector('history-panel-list');
        assert.isTrue(list.hasAttribute('hidden'));
      });

      test('Selection menu is hidden', () => {
        const list = element.shadowRoot.querySelector('.selection-options');
        assert.isTrue(list.hasAttribute('hidden'));
      });
    });

    suite('With data', () => {
      suiteSetup(() => {
        return DataGenerator.insertHistoryRequestData();
      });

      suiteTeardown(() => {
        return DataGenerator.destroyHistoryData();
      });

      let element;
      setup((done) => {
        element = fixture('Models')[3];
        doneAfterQuery(element, done);
      });

      test('hasRequests is true', () => {
        assert.isTrue(element.hasRequests);
      });

      test('empty message is not rendered', () => {
        const node = element.shadowRoot.querySelector('.empty-info');
        const display = getComputedStyle(node).display;
        assert.equal(display, 'none');
      });

      test('The list is visible', () => {
        const list = element.shadowRoot.querySelector('history-panel-list');
        assert.isFalse(list.hasAttribute('hidden'));
      });

      test('Selection menu is visible', () => {
        const list = element.shadowRoot.querySelector('.selection-options');
        assert.isFalse(list.hasAttribute('hidden'));
      });
    });
  });

  suite('_closeSelectionMenu()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = [];
      for (let i = 0; i < 5; i++) {
        list[i] = {
          _id: chance.guid({version: 5}),
          _rev: chance.guid({version: 5})
        };
      }
    });

    test('Does nothing when menu is not in the DOM', () => {
      element._closeSelectionMenu();
      // no error
    });

    test('Closes the menu', (done) => {
      element.requests = list;
      element.selectedItems = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#historyListMenu');
        menu.opened = true;
        element._closeSelectionMenu();
        assert.isFalse(menu.opened);
        done();
      });
    });

    test('Re-sets list selection', (done) => {
      element.requests = list;
      element.selectedItems = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#historyListMenuOptions');
        menu.selected = 1;
        element._closeSelectionMenu();
        assert.equal(menu.selected, -1);
        done();
      });
    });
  });

  suite('_closeMainMenu()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      list = [];
      for (let i = 0; i < 5; i++) {
        list[i] = {
          _id: chance.guid({version: 5}),
          _rev: chance.guid({version: 5})
        };
      }
    });

    test('Closes the main menu', (done) => {
      element.requests = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#mainMenu');
        menu.opened = true;
        element._closeMainMenu();
        assert.isFalse(menu.opened);
        done();
      });
    });

    test('Re-sets list selection', (done) => {
      element.requests = list;
      flush(() => {
        const menu = element.shadowRoot.querySelector('#mainMenuOptions');
        menu.selected = 1;
        element._closeMainMenu();
        assert.equal(menu.selected, -1);
        done();
      });
    });
  });

  suite('_deleteAllClick()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => done());
    });

    test('Closes main menu', () => {
      const menu = element.shadowRoot.querySelector('#mainMenu');
      menu.opened = true;
      element._deleteAllClick();
      assert.isFalse(menu.opened);
    });

    test('Opens data clear dialog', () => {
      const dialog = element.shadowRoot.querySelector('#dataClearDialog');
      element._deleteAllClick();
      assert.isTrue(dialog.opened);
    });
  });

  suite('_dispatchDeleteModel()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Dispatches "destroy-model" event', () => {
      const spy = sinon.spy();
      element.addEventListener('destroy-model', spy);
      element._dispatchDeleteModel();
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const result = element._dispatchDeleteModel();
      assert.typeOf(result, 'customevent');
    });

    test('Event is cancelable', () => {
      const result = element._dispatchDeleteModel();
      assert.isTrue(result.cancelable);
    });

    test('Event is composed', () => {
      const result = element._dispatchDeleteModel();
      if (typeof result.composed !== 'undefined') {
        assert.isTrue(result.composed);
      }
    });

    test('Event bubbles', () => {
      const result = element._dispatchDeleteModel();
      assert.isTrue(result.bubbles);
    });

    test('Event has detail object', () => {
      const result = element._dispatchDeleteModel();
      assert.typeOf(result.detail, 'object');
    });

    test('Detail has models', () => {
      const result = element._dispatchDeleteModel();
      assert.typeOf(result.detail.models, 'array');
    });

    test('Models has "history" item', () => {
      const result = element._dispatchDeleteModel();
      assert.deepEqual(result.detail.models, ['history']);
    });
  });

  suite('_clearDatastore()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Opens error toast when model is not found', (done) => {
      flush(() => {
        element._handleError = () => {};
        element._clearDatastore();
        const toast = element.shadowRoot.querySelector('#dataClearErrorToast');
        assert.isTrue(toast.opened);
        done();
      });
    });

    test('Throws error when no model', () => {
      assert.throws(() => {
        element._clearDatastore();
      }, 'Model not found.');
    });

    test('Opens error when model delete error', (done) => {
      element._handleError = () => {};
      element.addEventListener('destroy-model', function f(e) {
        element.removeEventListener('destroy-model', f);
        e.detail.result = [Promise.reject(new Error('test'))];
      });
      element._clearDatastore();
      flush(() => {
        const toast = element.shadowRoot.querySelector('#dataClearErrorToast');
        assert.isTrue(toast.opened);
        done();
      });
    });
  });

  suite('_onClearDialogResult()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Does nothing when dialog is not confirmed', () => {
      const spy = sinon.spy(element, '_clearDatastore');
      element._onClearDialogResult({
        detail: {
          confirmed: false
        }
      });
      assert.isFalse(spy.called);
    });

    test('Calls _clearDatastore() when confirmed', () => {
      const spy = sinon.spy(element, '_clearDatastore');
      element.addEventListener('destroy-model', function f(e) {
        element.removeEventListener('destroy-model', f);
        e.detail.result = [Promise.resolve()];
      });
      element._onClearDialogResult({
        detail: {
          confirmed: true
        }
      });
      assert.isTrue(spy.called);
    });
  });

  suite('_editRequestDetails()', () => {
    let element;
    let request;
    setup((done) => {
      element = fixture('Basic');
      flush(() => {
        request = DataGenerator.generateHistoryObject();
        const details = element.shadowRoot.querySelector('#requestDetails');
        details.request = request;
        element.detailsOpened = true;
        done();
      });
    });

    test('Closes request details dialog', () => {
      element._editRequestDetails();
      assert.isFalse(element.detailsOpened);
    });

    test('Opens request editor dialog', () => {
      element._editRequestDetails();
      assert.isTrue(element.editorOpened);
    });

    test('Clears request on detail dialog', () => {
      element._editRequestDetails();
      const details = element.shadowRoot.querySelector('#requestDetails');
      assert.isUndefined(details.request);
    });

    test('Sets request on editor dialog', () => {
      element._editRequestDetails();
      const editor = element.shadowRoot.querySelector('#requestEditor');
      assert.typeOf(editor.request, 'object');
    });

    test('Set request is a shallow copy', () => {
      element._editRequestDetails();
      const editor = element.shadowRoot.querySelector('#requestEditor');
      editor.request.url = 'test';
      assert.notEqual(request.url, 'test');
    });
  });

  suite('_cancelRequestEdit()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      element.editorOpened = true;
    });

    test('Closes editor dialog', () => {
      element._cancelRequestEdit();
      assert.isFalse(element.editorOpened);
    });
  });

  suite('_saveRequestEdit()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      element.editorOpened = true;
      flush(() => {
        const editor = element.shadowRoot.querySelector('#requestEditor');
        editor.request = DataGenerator.generateHistoryObject();
        done();
      });
    });

    test('Closes editor dialog', () => {
      element._saveRequestEdit();
      assert.isFalse(element.editorOpened);
    });

    test('Clears request from the editor', () => {
      element._saveRequestEdit();
      const editor = element.shadowRoot.querySelector('#requestEditor');
      assert.isUndefined(editor.request);
    });
  });

  suite('openExportAll()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _closeMainMenu()', () => {
      const spy = sinon.spy(element, '_closeMainMenu');
      element.openExportAll();
      assert.isTrue(spy.called);
    });

    test('Sets _exportOptionsOpened', () => {
      element.openExportAll();
      assert.isTrue(element._exportOptionsOpened);
    });

    test('Sets _exportItems', () => {
      element.openExportAll();
      assert.isTrue(element._exportItems);
    });
  });

  suite('_cancelExportOptions()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      element._exportOptionsOpened = true;
      element._exportItems = true;
    });

    test('Sets _exportOptionsOpened', () => {
      element._cancelExportOptions();
      assert.isFalse(element._exportOptionsOpened);
    });

    test('Sets _exportItems', () => {
      element._cancelExportOptions();
      assert.isUndefined(element._exportItems);
    });
  });

  suite('_exportAllFile()', () => {
    function handler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    let element;
    setup(() => {
      element = fixture('Basic');
      window.addEventListener('arc-data-export', handler);
    });

    teardown(() => {
      window.removeEventListener('arc-data-export', handler);
    });

    test('Calls _doExportItems()', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.isTrue(spy.called);
      return result;
    });

    test('First argument is true', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.isTrue(spy.args[0][0]);
      return result;
    });

    test('Second argument has options', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.typeOf(spy.args[0][1].options, 'object');
      return result;
    });

    test('Options has file', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.equal(spy.args[0][1].options.file, element._generateFileName());
      return result;
    });

    test('Options has kind', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.equal(spy.args[0][1].options.kind, 'ARC#HistoryExport');
      return result;
    });

    test('Options has provider', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._exportAllFile();
      assert.equal(spy.args[0][1].options.provider, 'file');
      return result;
    });
  });

  suite('_acceptExportOptions()', () => {
    function handler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    let element;
    setup(() => {
      element = fixture('Basic');
      window.addEventListener('arc-data-export', handler);
    });

    teardown(() => {
      window.removeEventListener('arc-data-export', handler);
    });

    test('Sets _exportOptionsOpened', () => {
      const result = element._acceptExportOptions({
        detail: {
          options: {}
        }
      });
      assert.isFalse(element._exportOptionsOpened);
      return result;
    });

    test('Calls _doExportItems()', () => {
      const spy = sinon.spy(element, '_doExportItems');
      const result = element._acceptExportOptions({
        detail: {
          options: {}
        }
      });
      assert.isTrue(spy.called);
      return result;
    });
  });

  suite('_updateListStyles()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _applyListStyles() for default type', () => {
      const spy = sinon.spy(element, '_applyListStyles');
      element._updateListStyles('default');
      assert.equal(spy.args[0][0], 56);
      assert.ok(spy.args[0][1]);
    });

    test('Calls _applyListStyles() for comfortable type', () => {
      const spy = sinon.spy(element, '_applyListStyles');
      element._updateListStyles('comfortable');
      assert.equal(spy.args[0][0], 40);
      assert.ok(spy.args[0][1]);
    });

    test('Calls _applyListStyles() for compact type', () => {
      const spy = sinon.spy(element, '_applyListStyles');
      element._updateListStyles('compact');
      assert.equal(spy.args[0][0], 36);
      assert.ok(spy.args[0][1]);
    });
  });
  </script>
</body>
</html>
